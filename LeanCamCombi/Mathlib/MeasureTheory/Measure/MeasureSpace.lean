import Project.Mathlib.Data.Set.Image
import Mathbin.Logic.Lemmas
import Mathbin.MeasureTheory.Measure.MeasureSpace

#align_import mathlib.measure_theory.measure.measure_space

open Function MeasureTheory Set

open scoped ENNReal MeasureTheory

variable {α β : Type _} [MeasurableSpace β] {f g : α → β} {s : Set β}

namespace MeasureTheory

variable [MeasurableSpace α] {μ : Measure α}

namespace Measure

@[simp]
theorem map_eq_zero_iff (hf : AEMeasurable f μ) : μ.map f = 0 ↔ μ = 0 :=
  by
  refine' ⟨fun h => _, _⟩
  · replace h := congr_fun (congr_arg coeFn h) Set.univ
    rwa [map_apply_of_ae_measurable hf MeasurableSet.univ, Set.preimage_univ, coe_zero,
      Pi.zero_apply, measure_univ_eq_zero] at h 
  · rintro rfl
    exact measure.map_zero _

@[simp]
theorem mapₗ_eq_zero_iff (hf : Measurable f) : Measure.mapₗ f μ = 0 ↔ μ = 0 := by
  classical
  rw [← map_eq_zero_iff hf.ae_measurable, map, dif_pos hf.ae_measurable,
    mapₗ_congr hf hf.ae_measurable.measurable_mk]
  exact hf.ae_measurable.ae_eq_mk

theorem map_ne_zero_iff (hf : AEMeasurable f μ) : μ.map f ≠ 0 ↔ μ ≠ 0 :=
  (map_eq_zero_iff hf).Not

theorem mapₗ_ne_zero_iff (hf : Measurable f) : Measure.mapₗ f μ ≠ 0 ↔ μ ≠ 0 :=
  (mapₗ_eq_zero_iff hf).Not

end Measure

instance Prop.measurableSpace : MeasurableSpace Prop :=
  ⊤

instance Prop.measurableSingletonClass : MeasurableSingletonClass Prop :=
  ⟨fun _ => trivial⟩

instance {α} : MeasurableSpace (Set α) :=
  ⊤

instance {α} : MeasurableSingletonClass (Set α) :=
  ⟨fun _ => trivial⟩

instance isProbabilityMeasure_neZero {α : Type _} [MeasurableSpace α] {μ : Measure α}
    [IsProbabilityMeasure μ] : NeZero μ :=
  ⟨IsProbabilityMeasure.ne_zero μ⟩

end MeasureTheory

namespace MeasurableSpace

variable [BooleanAlgebra β] (p : α → Prop)

theorem comap_of_involutive {g : β → β} (hg : Involutive g) (hg' : Measurable g) (f : α → β) :
    MeasurableSpace.comap (fun a => g (f a)) inferInstance =
      MeasurableSpace.comap f inferInstance :=
  by
  ext
  set e : Set β ≃ Set β :=
    { toFun := preimage g
      invFun := preimage g
      left_inv := hg.preimage
      right_inv := hg.preimage }
  refine' e.exists_congr_left.trans (exists_congr fun t => _)
  simp only [preimage_preimage, compl_compl, Equiv.coe_fn_symm_mk, and_congr_left_iff, hg _]
  rintro rfl
  refine' ⟨fun ht => _, fun ht => hg' ht⟩
  convert hg' ht
  simp_rw [preimage_preimage, hg _, preimage_id']

theorem comap_compl (h : Measurable (compl : β → β)) (f : α → β) :
    MeasurableSpace.comap (fun a => f aᶜ) inferInstance = MeasurableSpace.comap f inferInstance :=
  comap_of_involutive compl_involutive h _

@[simp]
theorem comap_not :
    MeasurableSpace.comap (fun a => ¬p a) inferInstance = MeasurableSpace.comap p inferInstance :=
  comap_compl (fun _ _ => trivial) _

end MeasurableSpace

theorem AEMeasurable.nullMeasurableSet_preimage [MeasurableSpace α] {μ : Measure α}
    (hf : AEMeasurable f μ) (hs : MeasurableSet s) : NullMeasurableSet (f ⁻¹' s) μ :=
  ⟨hf.mk _ ⁻¹' s, hf.measurable_mk hs, hf.ae_eq_mk.Preimage _⟩

namespace MeasureTheory

variable [MeasurableSpace α] {μ : Measure α}

-- change `measure_compl` to `measurable_set.compl` in the `measure_theory` namespace
theorem NullMeasurableSet.measure_compl {s : Set α} (h : NullMeasurableSet s μ) (hs : μ s ≠ ∞) :
    μ (sᶜ) = μ Set.univ - μ s :=
  by
  rw [← measure_congr h.to_measurable_ae_eq, ← measure_compl (measurable_set_to_measurable _ _)]
  · exact measure_congr h.to_measurable_ae_eq.symm.compl
  · rwa [measure_congr h.to_measurable_ae_eq]

theorem NullMeasurableSet.prob_compl_eq_one_sub [IsProbabilityMeasure μ] {s : Set α}
    (h : NullMeasurableSet s μ) : μ (sᶜ) = 1 - μ s := by
  rw [h.measure_compl (measure_ne_top _ _), measure_univ]

end MeasureTheory

namespace MeasurableSpace

/-- The sigma-algebra generated by a single set `s` is `{∅, s, sᶜ, univ}`. -/
@[simp]
theorem generateFrom_singleton (s : Set α) : generateFrom {s} = MeasurableSpace.comap (· ∈ s) ⊤ :=
  by
  classical
  refine' le_antisymm (generate_from_le fun t ht => ⟨{True}, trivial, by simp [ht.symm]⟩) _
  rintro _ ⟨u, -, rfl⟩
  by_cases hu₁ : True ∈ u <;> by_cases hu₀ : False ∈ u
  · rw [(_ : u = univ), preimage_univ]
    · exact MeasurableSet.univ
    · rw [eq_univ_iff_forall, Prop.forall]
      exact ⟨hu₁, hu₀⟩
  · rw [(_ : u = {True}), preimage_mem_singleton_true]
    · exact generate_measurable.basic _ (mem_singleton _)
    · simp [eq_singleton_iff_unique_mem, Prop.forall, hu₁, hu₀]
  · rw [(_ : u = {False}), preimage_mem_singleton_false]
    · exact generate_measurable.compl _ (generate_measurable.basic _ <| mem_singleton _)
    · simp [eq_singleton_iff_unique_mem, Prop.forall, hu₁, hu₀]
  · rw [(_ : u = ∅), preimage_empty]
    · exact @MeasurableSet.empty _ (generate_from _)
    · simp [eq_empty_iff_forall_not_mem, Prop.forall, hu₁, hu₀]

end MeasurableSpace

